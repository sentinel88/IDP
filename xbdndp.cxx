/********************************************************
  file xbdndp.cxx
  ````````````````
  Implementing genetic algorithm as a metaheuristic for a
  bilevel formulation of the discrete network design problem.

  (c) 2015 Private
      author: Nishanth Nagendra, Mar. 2015
********************************************************/

#include <defs.h>
#include <data.h>
#include <funcs.h>

/***********************************************************************/

int main(int argc, char **argv)
{

/***Declarations***/

 //model_data dndp;            /* Structure variable representing all modeling data */

 genetic_algo ga;            /* Genetic algorithm instance */

 network_data netinfo;      /* Structure variable representing network information */

 candidate *gen_children;   /* New set of children created from crossover or mutation operations */
 
 int i, j, k, l, m;           /* Iteration variables */
 float ta, xa, ba, ca, Constant;
 int r, s, flag = 0, count = 0, ret = 0, pool_size;
 float temp;

 printf("\nHello\n");

 ga.population_size = GA_POPULATION_SIZE;
 ga.iterations = GA_ITERATIONS;
 ga.population = (candidate *)malloc( (ga.population_size) * sizeof(candidate));
 memset(ga.population, 0, sizeof(ga.population_size) * sizeof(candidate));
 
 gen_children = (candidate *)(malloc(ga.population_size * sizeof(candidate)));
 memset(gen_children, 0, sizeof(gen_children)); 

 //gen_children = NULL;

/***Initial population generated by a set of random candidates***/
 printf("\nHello 2\n");

 parse(&netinfo);

 //model_problem(&dndp, &netinfo, &ga);

 //i = 0;
 //while (i <= ga.population_size) {
    ret = generate_rand(&ga, netinfo);
  //  i++;
 //}

 i = 0;
 for (i=0; i<ga.iterations; i++) {
    printf("\nGenetic algorithm: Iteration %d\n", i+1);
       //model_data dndp;
    for (j=0; j<ga.population_size; j++) {
       //dndp.p = XPRBnewprob("TAP");
       model_data dndp;
       //dndp = (model_data *)(malloc(sizeof(model_data)));
       //model_data dndp;
       //memset(dndp, 0, sizeof(model_data));
       printf("\nIteration %d: Candidate %d\n", i+1, j+1);
    /***Construction of new links***/
      /* for (k=0; k<NL; k++) {
          r = netinfo.new_links[k].orig;
          s = netinfo.new_links[k].term;
          dndp.Ya[r][s] = dndp.p.newVar("New link", XPRB_BV);
          printf("\tbin value: %d", ga.population[j].binary_enc[k]);
          dndp.Ya[r][s].fix(ga.population[j].binary_enc[k]);
          printf("\nValue fixed for Ya is: %f", dndp.Ya[r][s].getSol());
       }*/
       remodel_problem(&dndp, &netinfo, ga.population[j]);
       dndp.p.lpOptimize("");  
       printf("\nObjective value: %f\n", dndp.p.getObjVal());
       candidate_fitness(&dndp, &netinfo, &(ga.population[j]));
       
       /*for (k=0; k<NL; k++) {
          dndp->Ya[r][s].fix(0.0);
       }*/
       //free(dndp);
       //dndp.p.reset();
       //XPRBdelprob(&(dndp.p));
    }

    candidates_sort(ga.population);

    pool_size = genetic_sp_crossover(&ga, gen_children);
    //genetic_mutation(gen_children);

    k = 0; j = 0;
    //pool_size = sizeof(gen_children)/sizeof(candidate);
    for (k=0; k<pool_size; k++) {
       model_data dndp; 
       printf("Iteration(Generation): %d, Child no: %d\n", i+1, k+1);
       /*for (j=0; j<NL; j++) {
          r = netinfo.new_links[j].orig;
          s = netinfo.new_links[j].term;
          dndp.Ya[r][s] = dndp.p.newVar("New link", XPRB_BV);
          dndp.Ya[r][s].fix(gen_children[k].binary_enc[j]);
          printf("\nValue fixed for Ya is: %f", dndp.Ya[r][s].getSol());
       }*/
       remodel_problem(&dndp, &netinfo, gen_children[k]); 
       dndp.p.lpOptimize("");
       printf("\nObjective value: %f\n", dndp.p.getObjVal());
       candidate_fitness(&dndp, &netinfo, &gen_children[k]);
       //XPRBdelprob(dndp.p);
    } 

    candidates_sort(gen_children);

/***Select the candidates for the next generation from the pool of children and current population***/
   candidate *new_gen = (candidate *)(malloc(GA_POPULATION_SIZE * sizeof(candidate)));
   memset(new_gen, 0, sizeof(new_gen));

   l = 0; k = 0; j = 0;
   while(1) {
      if (gen_children[k].fitness_value <= ga.population[j].fitness_value) {
         memcpy(&new_gen[l], &gen_children[k], sizeof(candidate));
         k++;
      } else {
         memcpy(&new_gen[l], &(ga.population[j]), sizeof(candidate));
         j++;
      }
      l++;
      //k++; j++;
      if (l == GA_POPULATION_SIZE) break;
   }
   
   free(ga.population);
   ga.population = new_gen;
   new_gen = NULL;

 }

/*

 k = 0;

 while(1) {
    i = (rand() % NL);
    printf("\n%d\t", i);
    //i = ga.population[count].binary_enc = (rand() % NL);
    if (i == 0) continue;
    while(i) {
       ga.population[count].binary_enc[k++] = i&1;
       i = i>>1;
       printf("%d ", ga.population[count].binary_enc[k-1]);
    }
    //printf("\n%d\n", ga.population[count].binary_enc);
    count++;
    if (count == 5) break;
 }*/

 printf("\nFinal objective value for DNDP is %f\n", ga.population[0].fitness_value);

 free(gen_children);
 free(ga.population);
 gen_children = NULL;
 clean(&netinfo);

 return 0;  
}
