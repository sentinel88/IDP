1. Use a single bit for encoding of a new link. We can have a void * pointer in the candidate data structure and initialize this pointer to a memory location allocated in the main function for some number of bytes calculated using (NL/8).

2. Implement tournament selection.

3. Convert C to C++ code.

4. Can cache the results of the previous generation/ all generations till now for all the unique candidates to avoid repeated computation of problems by re using these results. Could be implemented as a 1D array whose size is determined at runtime based on the number of iterations and generation size and also on maybe caching only the top n values of a particular generation instead of all. Also a hash table could be implemented for large amount of caching.

5. Stop the genetic algorithm based on objective function value stagnation over a sequence of iterations say 5.

6. Use memcmp instead of an iterative byte by byte comparison.

7. Make the application configurable for different settings of genetic algorithm parameters.

8. For low budgets keep the MAX_BEST_ITERATIONS value low whereas for higher budget problems keep this macro value high.

9. Crossover operations result in new candidates. We can try to see that these candidates are not the same as the ones already generated in our present parent population or we can always keep a global set of candidates generated but this will result in a huge search time.

10. Create only how many children are feasibly possible even if the resultant pool size is small. If by repeated attempts we do not get unique children then do not add duplicates to the pool.

11. If zero no. of children have been generated from crossover operations since the last few iterations then we can stop the genetic algorithm
because it does not help to continue further without any more improvements.
